cmdhistory=["(class (second (ast->clj (parser \\"`(+ 1 1)\\"))))" "(class (second (ast->clj (parser \\"'(+ 1 1)\\"))))" "(class (second (ast->clj (parser \\"~(+ 1 1)\\"))))" "(evl (quote (a-fn 2)))" "(if-let [a nil] \:a \:b)" "(evl (quote (a-fn 2)))" "(quote (a-fn 2))" "(evl (quote (a-fn 2)))" "(evl (quote (if true (println \\"hej\\" (println \\"asdf\\")))))" "(evl (if true (println \\"hej\\" (println \\"asdf\\"))))" "'(if true (println \\"hej\\" (println \\"asdf\\")))" "~'(if true (println \\"hej\\" (println \\"asdf\\")))" "`'(if true (println \\"hej\\" (println \\"asdf\\")))" "`~(if true (println \\"hej\\" (println \\"asdf\\")))" "(evl (+ 1 1))" "(evl (quote (+ 1 1)))" "(evl (unqoute (quote (+ 1 1))))" "(evl (unquote (quote (+ 1 1))))" "(evl (unquote (+ 1 1)))" "(unquote 1)" "(unquote '(+ 1 1))" "(evl (unquote (quote (+ 1 1))))" "(evl (quote (+ 1 1)))" "(evl (unquote (quote (+ 1 1))))" "(evl (unquote (quote (+ 1 (- 10 5)))))" "(evl (quote (+ 1 (- 10 5))))" "(evl (if true 1 0))" "(evl (if false 1 0))" "(apply and [false true])" "(evl (def a 1))" "(evl (def b 2))" "(evl (if (\= a b) 10 11))" "(evl (def a 2))" "(evl (if (\= a b) 10 11))" "(apply-macro \\"and\\" [1 2 3] {})" "(macroexpand-1 '(apply-macro \\"and\\" [1 2 3] {}))" "(evl (and false true))" "(reduce (fn [acc b] (and acc b)) [false true])" "(reduce (fn [acc b] (and acc b)) [true true])" "(reduce (fn [acc b] (and acc b)) [true true false])" "(reduce (fn [acc b] (or acc b)) [true true false])" "(reduce (fn [acc b] (or acc b)) [false false false])" "(evl (and false true))" "(evl (or false true))" "(evl (and false true))" "(evl (and true true))" "(evl (or true true))" "(evl (or true false))" "(evl (or false false))" "(evl (and false false))" "(evl (and false true))" "(evl (and true true))" "(evl (def >\= (fn [v1 v2] (or (> v1 v2) (\= v1 v2)))))" "(evl (>\= 2 2))" "(evl (>\= 3 2))" "(evl (>\= 1 2))" "(evl (<\= 1 2))" "(evl (abs -1))" "(evl (abs 1))" "(evl (first [1 2 3]))" "(evl (rest [1 2 3]))" "(cons 1 [2 3])" "(evl (cons 1 [2 3]))" "vars" "@vars" "vars" "@vars" "(@vars min)" "(@vars \\"min\\")" "(@vars (symbol \\"min\\"))" "(meta (@vars (symbol \\"min\\")))" "(meta (with-meta (@vars (symbol \\"min\\")) \:type \:macro))" "(meta (with-meta (@vars (symbol \\"min\\")) {\:type \:macro}))" "(def a (with-meta (@vars (symbol \\"min\\")) {\:type \:macro}))" "a" "(meta a)" "(nth [1] 1)" "(rest [0 1])" "(second (rest [0 1]))" "(@vars (symbol \\"min\\"))" "(meta (@vars (symbol \\"min\\")))" "(macroexpand-1 '(and false true))" "(macroexpand-1 '(and false (\= 1 2)))" "(in-ns 'user)" "(source max)" "(source and)" "(source or)" "(my-and false false)" "(source and)" "(defn a [x & args])" "(defn a [x & y & args])" "(defn a [x & y args])" "(source >\=)" "(source max)" "(evl (min 1 2))" "(source max)" "(evl (max 1))" "(evl (min 1 2))" "(evl (max 1))" "[x y & args]" "'[x y & args]" "(arity '[x y & args])" "(arity '[x y  args])" "(arity '[x y  & args])" "(evl (max 1))" "(evl (min 1 2))" "(args-of '(x y & args) [1 2 3 4 5])" "(args-of '[x y & args] [1 2 3 4 5])" "(subvec '[x y & args] 0 2)" "(args-of '[x y & args] [1 2 3 4 5])" "(evl (min 1 2))" "(evl (max 1))" "(evl (max 1 2))" "(evl (max 1))" "(evl (max 1 2 3))" "(conj [1] 2)" "(evl (max 1 2 3))" "(source reduce)" "(reduce + [1 2 3])" "(reduce + 1 [1 2 3])" "(reduce (fn [v] v) 1 [1 2 3])" "(source +)" "(rd + 0 [1 2 3])" "(rd + 1 [1 2 3])" "(rest [])" "(nil? (rest []))" "(seq (rest [])a)" "(seq (rest []))" "(seq (rest [1]))" "(seq (rest [1 2]))" "(seq  [])" "(empty? [])" "(co [1 2 4])" "(evl (count [1 2]))" "(evl 1)" "(evl \:a)" "(evl [1 2])" "(evl '(1 2))" "(evl (count '(1 2)))" "(evl (first '(1 2)))" "(evl (rest '(1 2)))" "(evl (and true false))" "(evl (quote (and true false)))" "(evl (count []))" "(evl (first [1]))" "(evl (empty? [1]))" "(evl (empty? []))" "(evl (count []))" "(evl (count [1]))" "(evl (emtpy [1]))" "(evl (empty [1]))" "(evl (empty? [1]))" "(evl (empty? []))" "(empty? [])" "(evl [])" "(instance? java.util.List [])" "(empty? '())" "(empty? '(1))" "(empty? [1 2])" "(evl [1 2])" "(instance? clojure.lang.IPersistentVector [])" "(instance? clojure.lang.IPersistentVector '())" "(instance? clojure.lang.IPersistentList [])" "(evl '(1 2))" "(evl (count '(1 2)))" "(evl (empty? '(1 2)))" "(evl (empty? '()))" "(evl (rest '(1 2)))" "(evl (rest (quote (1 2))))" "(evl (quote (1 2)))" "(evl (empty? (quote (1 2))))" "(evl (empty? (quote ())))" "(evl (first (quote (1))))" "(evl (first (quote (1 2))))" "(evl (first (quote (10 1 2))))" "(evl (rest (quote (1 2))))" "(evl (rest (quote (1 2 3))))" "(evl (count (quote (1 2 3))))" "(evl (empty? (quote (1 2 3))))" "(evl (empty? (quote ())))" "(evl (empty? (quote (1 2))))" "(evl (empty? (rest (quote (1 2)))))" "(evl (empty? (rest (quote (1)))))" "(evl (count (quote (1 2 3))))" "(evl (count (quote ())))" "(evl (first (quote 1 2)))" "(evl (rest (quote 1 2)))" "(evl (rest (quote (1 2))))" "(evl (first (quote (1 2))))" "(evl (def a 1))" "(evl a)" "(evl (def a 1))" "(evl a)" "(evl (first (qoute (1 2))))" "(evl (first (quote (1 2))))" "(evl (rest (quote (1 2))))" "(evl (rest (quote (1 2 3))))" "(evl (rest (quote (1 2 3 4))))" "(evl (empty? (quote (1 2 3 4))))" "(evl (count (quote (1 2 3 4))))" "(evl (def a 1))" "(evl a)" "(evl (+ a 1))" "(evl (+ a 1 1))" "(evl (def a 1))" "(evl (+ a 1 1))" "(evl (quoute (a 1 2)))" "(evl (quote (a 1 2)))" "(evl (rest (quote (a 1 2))))" "(evl (rest (quote (a a 2))))" "(evl (rest (quote (a a a))))" "(evl (rest (rest (quote (a a a)))))" "(evl (rest (rest (quote (1 2 3)))))" "(evl (count (rest (rest (quote (1 2 3))))))" "(evl (empty? (rest (rest (quote (1 2 3))))))" "(evl (rest (rest (quote (1 2 3)))))" "(evl (rest (quote (1))))" "(evl (count (quote (1))))" "(evl (if true 1 0))" "(evl (if false 1 0))" "(evl (if (empty? (quote ()) 1 0)))" "(evl (if (empty? (quote ())) 1 0))" "(evl (if (empty? (quote (1))) 1 0))" "(co [1 2])" "(co '[1 2])" "(co '(1 2))" "(evl (count (quote (1))))" "(evl (if true (println \\"t\\") (println \\"f\\")))" "(evl (if false (println \\"t\\") (println \\"f\\")))" "(evl (def count (fn [coll] (if (empty? coll) 0 1))))" "(evl (count (quote ())))" "(evl (count (quote (1))))" "(evl (def count (fn [coll] 1)))" "(evl (count (quote ())))" "(evl (def count (fn [coll] coll)))" "(evl (count (quote ())))" "(evl (quote ()))" "(evl (rest (quote (1))))" "(evl (first (quote (1))))" "(evl (first (quote (1 2))))" "(evl (rest (quote (1 2))))" "(evl (second (quote (1 2))))" "(evl (rest (quote (1 2))))" "(evl (first (rest (quote (1 2)))))" "(evl (second (quote (1 2))))" "(evl (def a (fn [] 10)))" "(evl (second (quote (a 2))))" "(evl ((fn [coll] (first (rest coll))) (quote (a 2))))" "(evl ((fn [coll] (first (rest coll))) (quote (1 2))))" "(eval '(1 2))" "'(1 2)" "(eval [1 2])" "(eval (eval [1 2]))" "(evl ((fn [coll] (first (rest coll))) (quote (a 2))))" "(evl (quoute (1 2 3)))" "(evl (quote (1 2 3)))" "(evl (def (quote (1 2 3))))" "(evl (def a (quote (1 2 3))))" "a" "(evl a)" "(evl (def a (fn [] (quote (1 2 3)))))" "a" "(evl a)" "(evl (a))" "(evl (def a (fn [] (quote (1 2 3)))))" "(evl ((fn [coll] (first (rest coll))) (quote (a 2))))" "(eval (quote (1 2)))" "(evl (quote (1 2)))" "(evl (rest (quote (1 2))))" "(my-apply '(+ 1 1))" "(my-apply '(+ 1 1) {})" "(my-apply '1 {})" "(evl (min 1 2))" "(new-eval 1)" "(new-eval 1 {})" "(new-eval \\"asdf\\" {})" "(new-eval \:asdf {})" "(new-eval 'asdf {})" "(new-eval asdf {})" "(new-eval 'asdf {})" "(symbol? 'asdf)" "(new-eval 'asdf {})" "(new-eval '(quoted 1) {})" "(new-eval '(def a 1) {})" "(new-eval 'a {})" "(new-eval '(if true true false))" "(new-eval '(if true true false) {})" "(new-eval '(if false true false) {})" "(new-eval '(if nil true false) {})" "(new-eval '(if \\"sadf\\" true false) {})" "(new-eval '(+ 1 1) {})" "(new-eval '(def a 1) {})" "(new-eval '(def b a) {})" "(new-eval 'b {})" "(new-eval '(def a 1) {})" "(new-eval '(def b a) {})" "(new-eval 'b {})" "(new-eval '(+ 1 1) {})" "(fn? '())" "(fn? [])" "(fn? +)" "(new-eval '(+ 1 1) {})" "(swap\! assoc vars '+ +)" "vars" "(swap\! vars assoc '+ +)" "(new-eval '(+ 1 1) {})" "(@vars '+)" "(swap\! vars assoc '+ +)" "(new-eval '(+ 1 1) {})" "(new-eval '+ {})" "(swap\! vars assoc '+ +)" "(new-eval '+ {})" "(new-eval '1 {})" "(new-eval '+ {})" "(swap\! vars assoc '+ +)" "(new-eval '+ {})" "vars" "(swap\! vars assoc '+ +)" "(new-eval '+ {})" "(fn? +)" "(new-eval '+ {})" "(swap\! vars assoc '+ +)" "(new-eval '(+ 1 1) {})" "(new-eval '+ {})" "(new-eval + {})" "(swap\! vars assoc '+ +)" "(new-eval '(+ 1 1) {})" "(new-eval '(println \\"hej\\") {})" "(new-eval '(quote ( \\"hej\\")) {})" "(new-eval '(quote (1 2)) {})" "(new-eval '(println (quote (1 2))) {})" "(println (quote (1 2)))" "(new-eval '(println (quote (1 2))) {})" "(new-eval '(rest (quote (1 2))) {})" "(new-eval '(first (quote (1 2))) {})" "(new-eval '(first (quote (1 2 3))) {})" "(new-eval '(rest (quote (1 2 3))) {})" "(new-eval '(rest (rest (quote (1 2 3)))) {})" "(new-eval '(empty? (rest (rest (quote (1 2 3))))) {})" "(new-eval '(empty? (rest (rest (quote (1 2))))) {})" "(new-eval '(a 1) {})" "(new-eval '(def inc (fn [x] (+ x 1)) {}))" "(new-eval '(def inc (fn [x] (+ x 1))) {})" "vars" "(new-eval '(inc 1) {})" "(@vars 'inc)" "vars" "(keys vars)" "(keys @vars)" "(new-eval '(def inc (fn [x] (+ x 1))) {})" "(@var 'inc)" "(@vars 'inc)" "(new-eval '(inc 1) {})" "(@vars 'inc)" "(new-eval '(def inc (fn [x] (+ x 1))) {})" "(new-eval '(inc 1) {})" "(new-eval '(def inc (fn [x] (+ x 1))) {})" "(new-eval '(inc 1) {})" "(new-eval '(def inc (fn [x] (+ x 1))) {})" "(new-eval '(inc 1) {})" "dbg" "(new-eval '(def inc (fn [x] (+ x 1))) {})" "(new-eval '(inc 1) {})" "(symbol? [])" "(symbol? '())" "(new-eval '(def inc (fn [x] (+ x 1))) {})" "(new-eval '(inc 1) {})" "(new-eval '(def inc (fn [x] (+ x 1))) {})" "(new-eval '(inc 1) {})" "(new-eval '(def inc (fn [x] (+ x 1))) {})" "(new-eval '(inc 1) {})" "(new-eval '(def inc (fn [x] (+ x 1))) {})" "(new-eval '(inc 1) {})" "dbg" "(new-eval '(def inc (fn [x] (+ x 1))) {})" "(new-eval '(inc 1) {})" "(new-eval '(def inc (fn [x] (+ x 1))) {})" "(new-eval '(inc 1) {})" "(new-eval '(fn [x] (+ x 1)) {})" "(new-eval '((fn [x] (+ x 1)) 1) {})" "(new-eval '((fn [x] (if true 1 0)) 1) {})" "(new-eval '(if true 1 0) {})" "(new-eval 1 {})" "(new-eval \:a {})" "(new-eval '(if true 1 0) {})" "(new-eval '(+ 1 1) {})" "(fn? +)" "(self-eval? +)" "(new-eval '(+ 1 1) {})" "(self-eval? nil)" "(self-eval? '())" "(self-eval? 1)" "(self-eval? \:a)" "(self-eval? +)" "(new-eval '(+ 1 1) {})" "(list? +)" "(new-eval '(+ 1 1) {})" "(new-eval '(if true 1 0) {})" "(new-eval '((fn [x] (if true 1 0)) 1) {})" "(new-eval '((fn [x] (+ x 1) 1)) {})" "(new-eval '((fn [x] (+ x 1)) 1) {})" "(new-eval '((fn [x] (+ x 1)) 2) {})" "(new-eval '(def inc (fn [x] (+ x 1))) {})" "(new-eval '(inc 2) {})" "(new-eval '(inc (- 3 2)) {})" "(new-eval '(def max\\n  (fn \\n    ([x] x)\\n    ([x y] (if (> x y) x y))\\n    ([x y & more]\\n     3))))" "(new-eval '(def max\\n  (fn \\n    ([x] x)\\n    ([x y] (if (> x y) x y))\\n    ([x y & more]\\n     3))) {})" "(new-eval '(max 1) {})" "(new-eval '(max 1 2) {})" "(new-eval '(max 1 2 3) {})" "(new-eval '(max 1 2) {})" "(new-eval '(def max\\n  (fn \\n    ([x] x)\\n    ([x y] (if (> x y) x y))\\n    ([x y & more]\\n     3))) {})" "(new-eval '(max 1 2) {})" "(new-eval '(def max\\n  (fn \\n    ([x] x)\\n    ([x y] (if (> x y) x y))\\n    ([x y & more]\\n     3))) {})" "(new-eval '(max 1 2) {})" "(new-eval '(max 1 2 3) {})" "(new-eval '(max 1 2 3 4) {})" "(new-eval '(max 1 2 3) {})" "(new-eval '(def max\\n  (fn \\n    ([x] x)\\n    ([x y] (if (> x y) x y))\\n    ([x y & more]\\n     3))) {})" "(new-eval '(max 1 2 3) {})" "(new-eval '(max 1 2 3 4) {})" "(new-eval '(def max\\n  (fn \\n    ([x] x)\\n    ([x y] (if (> x y) x y))\\n    ([x y & more]\\n     3))) {})" "(new-eval '(max 1 2 3 4) {})" "(new-eval '(def max\\n  (fn \\n    ([x] x)\\n    ([x y] (if (> x y) x y))\\n    ([x y & more]\\n     3))) {})" "(new-eval '(max 1 2 3 4) {})" "(new-eval '(def max\\n  (fn \\n    ([x] x)\\n    ([x y] (if (> x y) x y))\\n    ([x y & more]\\n     3))) {})" "(new-eval '(max 1 2 3 4) {})" "(new-eval '(def max\\n  (fn \\n    ([x] x)\\n    ([x y] (if (> x y) x y))\\n    ([x y & more]\\n     3))) {})" "(new-eval '(max 1 2 3 4) {})" "(new-eval '(def max\\n  (fn \\n    ([x] x)\\n    ([x y] (if (> x y) x y))\\n    ([x y & more]\\n     3))) {})" "(new-eval '(max 1 2 3 4) {})" "(new-eval '(def max\\n  (fn \\n    ([x] x)\\n    ([x y] (if (> x y) x y))\\n    ([x y & more]\\n     3))) {})" "(new-eval '(max 1 2 3 4) {})" "(new-eval '(def max\\n  (fn \\n    ([x] x)\\n    ([x y] (if (> x y) x y))\\n    ([x y & more]\\n     3))) {})" "(new-eval '(max 1 2 3 4) {})" "(new-eval '(def max\\n  (fn \\n    ([x] x)\\n    ([x y] (if (> x y) x y))\\n    ([x y & more]\\n     3))) {})" "(new-eval '(max 1 2 3 4) {})" "(new-eval '(def max\\n  (fn \\n    ([x] x)\\n    ([x y] (if (> x y) x y))\\n    ([x y & more]\\n     3))) {})" "(new-eval '(max 1 2 3 4) {})" "(new-eval '(def max\\n  (fn \\n    ([x] x)\\n    ([x y] (if (> x y) x y))\\n    ([x y & more]\\n     3))) {})" "(new-eval '(max 1 2 3 4) {})" "(new-eval '(max 1 2 3 ) {})" "(new-eval '(max 1 2 ) {})" "(new-eval '((fn [x y] (if (> x y) true false)) 1 0) {})" "(new-eval '((fn [x y] (if (> x y) 1 0)) 1 0) {})" "(new-eval '((fn [x y] (if (> x y) 1 0)) 1 2) {})" "(new-eval '((fn [x y] (if (> x y) 2 0)) 1 2) {})" "(new-eval '(if (> 1 0) true false) {})" "(instance? Boolean true)" "(instance? Boolean 0)" "(new-eval '(if (> 1 0) true false) {})" "(new-eval '(if (> 1 2) true false) {})" ">" "(new-eval '(> 1 2) {})" "(new-eval '(> 1 0) {})" "(new-eval '(if true true false) {})" "(new-eval '(if false true false) {})" "(new-eval '(if true true false) {})" "(new-eval '(if false true false) {})" "(new-eval '((fn [x y] (if (> x y) 1 0)) 1 2) {})" "(new-eval '((fn [x y] (if (> x y) 1 0)) 1 0) {})" "(new-eval '(def max\\n  (fn \\n    ([x] x)\\n    ([x y] (if (> x y) x y))\\n    ([x y & more]\\n     3))) {})" "(new-eval '(max 1 2 ) {})" "(new-eval '(max 3 2 ) {})" "(new-eval '(max 1 2 3 ) {})" "(new-eval '(max 1 2 3 4) {})" "(new-eval '(def max\\n  (fn \\n    ([x] x)\\n    ([x y] (if (> x y) x y))\\n    ([x y & more]\\n     3))) {})" "(new-eval '(max 1 2) {})" "(new-eval '(max 1 2 3) {})" "(new-eval '(def max\\n  (fn \\n    ([x] x)\\n    ([x y] (if (> x y) x y))\\n    ([x y & more]\\n     3))) {})" "(new-eval '(max 1 2 3 4) {})" "vars" "(run-tests)" "(rd + 0 [1 2 3])" "(new-eval (rd + 0 [1 2 3]) {})" "(new-eval '(rd + 0 [1 2 3]) {})" "(new-eval '(reduce + 0 [1 2 3]) {})" "@vars" "(new-eval '(reduce + 0 [1 2 3]) {})" "(new-eval '(count (1 2)) {})" "(new-eval '(rest (1 2)) {})" "(new-eval '(rest (quote (1 2))) {})" "(new-eval '(count (quote (1 2))) {})" "(new-eval '(reduce + 0 (quote (1 2 3))) {})" "(new-eval '(reduce + 0 (+ 1 2 3)) {})" "(new-eval '(reduce + 0 (quote (1 2 3))) {})" "(new-eval '(+ (rest (quote (1 2 3)))) {})" "(new-eval '(rest (quote (1 2 3))) {})" "(new-eval '(rest (rest (quote (1 2 3)))) {})" "(new-eval '(first (rest (quote (1 2 3)))) {})" "(new-eval '(def (quote (1 2 3))) {})" "(new-eval '(def a (quote (1 2 3))) {})" "(new-eval 'a {})" "(new-eval '(count a))" "(new-eval '(count a) {})" "(new-eval '(if (empty? a) (first a) (rest a)) {})" "(run-tests)" "(def a 1)" "(def b (+ a 1))" "b" "(def a 2)" "b" "(run-tests)" "(new-eval '(def a b) {})" "(@vars 'a)" "(new-eval '(def a b) {})" "(@vars 'a)" "(@vars 'b)" "(def a b)" "(contains? (keys (@vars)) 'a)" "(contains? (keys @vars) 'a)" "(contains? (keys (@vars)) 'a)" "(contains? (keys @vars) 'a)" "(contains? (into \#{} (keys @vars)) 'a)" "(contains? (into \#{} (keys @vars)) 'b)" "b" "(new-eval '(def a b) {})" "(new-eval '(def a 1) {})" "(new-eval '(def b a) {})" "(new-eval 'a {})" "(new-eval 'b {})" "(new-eval '(def b (+ a 1)) {})" "(new-eval 'b {})" "(new-eval 'a {})" "(new-eval '(def b a) {})" "(new-eval '(def a 1) {})" "(new-eval 'a {})" "(new-eval '(def a 1) {})" "(new-eval 'a {})" "(new-eval '(def b (+ a 1)) {})" "(new-eval 'b {})" "(new-eval '(fn [x] (+ x 1)) {})" "(meta (new-eval '(fn [x] (+ x 1)) {}))" "(new-eval '((fn [x] (+ x 1)) 1) {})" "(run-tests)" "(new-eval '((fn [x] (+ x 1)) 1) {})" "(new-eval '() {})" "(new-eval '(1) {})" "(new-eval '(1 2) {})" "(new-eval '(quote a) {})" "(new-eval 'a {})" "(new-eval '(empty? (quote (1 2))) {})" "(new-eval '(rest (quote (1 2))) {})" "(conj '(1) 2)" "(new-eval '(rest (quote (1 2))) {})" "(conj 'quote '(1 2))" "(conj '('quote) '(1 2))" "(conj '(quote) '(1 2))" "(cons '(quote) '(1 2))" "(cons [1 2] 'quote)" "(conj [1 2] 'quote)" "(conj [1 2] ['quote])" "(cons [1 2] ['quote])" "(concat [1 2] ['quote])" "(conj ['quote] [1 2])" "(conj ('quote) (1 2))" "(conj '('quote) (1 2))" "(conj '(quote) (1 2))" "(conj '(quote) '(1 2))" "(cons '(quote) '(1 2))" "(new-eval '(rest (quote (1 2))) {})" "(run-tests)" "(new-eval '(rest (quote (1 2))) {})" "(eval (new-eval '(rest (quote (1 2))) {}))" "(list  1 2 3)" "(new-eval '(rest (quote (1 2 3))) {})" "(eval (new-eval '(rest (quote (1 2 3))) {}))" "(new-eval '(rest (quote (1 2 3))) {})" "(run-tests)" "(new-eval '(list 1 2 3) {})" "(new-eval (list 1 2 3) {})" "(run-tests)" "(new-eval '(reduce + 0 (list 1 2 3)) {})" "(run-tests)" "(evl (max 1 2))" "(evl (count (qoute (1 2 3))))" "(evl (count (list 1 2 3)))" "(evl (qoute (1 2 3)))" "(evl (quote (1 2 3)))" "(evl (count (quote (1 2 3))))" "(evl (second (quote (1 2 3))))" "(run-tests)" "(evl ((fn [coll] (rest coll)) (list 1 2 3)))" "(run-tests)" "(rest '(list 1 2 3))" "(run-tests)" "(source max)" "(run-tests)" "(cons 1 nil)" "(run-tests)" "(evl '(reduce - (list 10 9 5)))" "(evl (reduce - (list 10 9 5)))" "(evl (reduce - 0 (list 10 9 5)))" "(reduce - 0 (list 10 9 5))" "(reduce - 0 (list 10 9 5))(fn-app fn-def '(0 2 4) {})" "(def fn-def '(([x] x) ([x y] (if (> x y) x y)) ([x y & more] 3)))" "(reduce - 0 (list 10 9 5))(fn-app fn-def '(0 2 4) {})" "(fn-app fn-def '(0 2 4) {})" "(fn-app fn-def '(0 2) {})" "(def fn-def '(([x] x) ([x y] (if (> x y) x y)) ([x y & more] 3)))" "(fn-app fn-def '(0 2 4) {})" "(def fn-def '(([x] x) ([x y] (if (> x y) x y)) ([x y & more] 3)))" "(fn-app fn-def '(0 2 4) {})" "(evl (max 1 2 3))" "(evl (max 1 2 3 4))" "(def fn-def '(([x] x) ([x y] (if (> x y) x y)) ([x y & more] (reduce max (max x y) more))))" "(evl (max 1 2 3 4))" "(fn-app fn-def '(0 2 4 10) {})" "(def fn-def '(([x] x) ([x y] (if (> x y) x y)) ([x y & more] (reduce max (max x y) more))))" "(fn-app fn-def '(0 2 4 10) {})" "(def fn-def '(([x] x) ([x y] (if (> x y) x y)) ([x y & more] (reduce max (max x y) more))))" "(fn-app fn-def '(0 2 4 10) {})" "(fn-app fn-def '(0 100 2 4 10) {})" "(fn-app fn-def '(0 100) {})" "(fn-app fn-def '(100) {})" "(run-tests)" "(evl (min 1 2 3))" "(evl (min 10 1 2 3))" "(evl (min 10 1 2 3 -10))" "(macroexpand-1 '(def-map))" "(macroexpand-1 '(def-map 1))" "(macroexpand-1 '(def-map first rest))" "'((quote first) first (quote rest) rest)" "(into {}'((quote first) first (quote rest) rest))" "(apply {}'((quote first) first (quote rest) rest))" "(apply {} '((quote first) first (quote rest) rest))" "(apply hash-map '((quote first) first (quote rest) rest))" "(macroexpand-1 '(def-map first rest))" "global-env" "(@global-env '+)" "(run-tests)" "(evl (+ (+ 1 1) 2))" "(source or)" "(source not)" "(evl (not true))" "(source not\=)" "(source apply)" "(evl (not\= true true))" "(evl (not\= false true))" "(evl (not\= false false))" "(source apply)" "(source not\=)" "(evl (not\= false false))" "(source and)" "(run-tests)" "(source defmacro)" "(run-tests)" "(eval (+ 1 1))" "(evl (+ 1 1))" "(evl (max 1 1))" "(evl (+ 1 1))" "(run-tests)" "(source and)" "(evl (quote 1))" "(evl (quote1 1))" "(run-tests)" "~1" "~'1" "'1" "`~1" "`~a" "(evl (quote1 1))" "(evl (quote 1))" "(evl (syntax-quote quote 1))" "(evl (syntax-quote (1)))" "(evl (syntax-quote 1))" "(source eval)" "(unquote (quoute 1))" "(unquote (quote 1))" "``()" "`'(1)" "(unquote? 1 true)" "(unquote? [] true)" "(unquote? ['uquote] true)" "(unquote? ['unquote] true)" "(run-tests)" "(evl (unquote 1))" "(evl (syntax-quote(unquote 1)))" "(evl (syntax-quote(unquote (+ 1 1))))" "(evl (syntax-quote (unquote (+ 1 1))))" "(evl (syntax-quote (+ 1 1)))" "(evl (syntax-quote asdf))" "(run-tests)" "(source and)" "\\n(evl (syntax-quote (unquote (+ 1 2))))" "\\n(evl (syntax-quote ((unquote (+ 1 2)))))" "\\n(evl (syntax-quote (list (unquote (+ 1 2)))))" "`(~(+ 1 2))" "(run-tests)" "(evl (syntax-quote ((unquote (+ 1 2)))))" "`(~(+ 1 2))" "(evl (syntax-quote ((unquote (+ 1 2)))))" "(run-tests)" "(evl (syntax-quote (+ 1 2)))" "(evl (syntax-quote ((unquote (+ 1 2)))))" "(evl (syntax-quote ((unquote (+ 1 2)) (1 2 3))))" "(run-tests)" "(evl (syntax-quote (if true 1 0)))" "(evl (def a 1))" "(evl a)" "(evl (syntax-quote (if true (unuote a) 0)))" "(run-tests)" "(evl (syntax-quote (def b (unquote a))))" "(evl (syntax-quote (def b (unquote (+ 1 2 3)))))" "(run-tests)" "(evl (fn [x] (+ x 1)))" "(evl (syntax-quote (fn [x] (+ x 1))))" "(evl (syntax-quote (fn [x] (+ x (+ 1 2 3)))))" "(evl (syntax-quote (fn [x] (+ x (unquote (+ 1 2 3))))))" "(run-tests)" "(evl (syntax-quote (fn [x] (+ x (unquote (+ 1 2 3))))))" "(evl ((syntax-quote (fn [x] (+ x (unquote (+ 1 2 3))))) 0))" "~(fn [x] ~x)" "`(fn [x] ~x)" "`(fn [x\#] ~x\#)" "`(fn [x\#] x\#)" "(run-tests)" "(evl ((syntax-quote (fn [x] (+ x (unquote (+ 1 2 3))))) 0))" "(evl (syntax-quote (fn [x] (+ x (unquote (+ 1 2 3))))))" "'[a b c]" "`[a b c]" "(evl [1 2])" "(evl [1 (+ 1 2 4)])" "(evl (syntax-quote [1 (+ 1 2 4)]))" "(evl (syntax-quote (syntax-quote [1 (+ 1 2 4)])))" "(evl (syntax-quote (syntax-quote [1 (unquote (+ 1 2 4))])))" "(evl ((syntax-quote (fn [x] (+ x (unquote (+ 1 2 3))))) 0))" "(run-tests)" "(evl (syntax-quote (fn [x] (+ x (unquote (+ 1 2 3))))))" "(run-tests)" "(evl (max 1 2))" "(evl (def a 2))" "(evl (def a (fn a [x] (+ x 1))))" "(evl (a 1))" "(evl (def a (fn a [x] (+ x 1)) \:macro))" "(evl (a 1))" "(evl (def a (fn a [x] (+ x 1)) \:macro))" "(evl (a 1))" "(run-tests)" "(evl (def a (fn a [x] (+ x 1))))" "(evl (a 1))" "(evl (def a (fn a [x] x)))" "(evl (a 1))" "(evl (def a (fn a [x] x)))" "(evl (a 1))" "(evl a)" "(evl (max 1 2))" "(evl (max 1))" "(evl (abs 1 2))" "(evl (abs 1))" "(evl (def a (fn [v] v)))" "(evl (a 1))" "(evl (def a (fn [v] v) \:macro))" "(evl (a 1))" "(evl (def a (fn [v] v) \:macro))" "(evl (a 1))" "(evl (def a (fn [v] v) \:macro))" "(evl (a 1))" "(evl (a b))" "(evl (a (syntax-quote b)))" "(evl (a (syntax-quote (unquote b))))" "(defmacro asdf [x]\\n  x)" "(asdf 1)" "(evl (def a (fn [v] v) \:macro))" "(evl (a 1))" "(evl (def a (fn [v] v)))" "(evl (a 1))" "(evl (def a (fn [v] v) \:macro))" "(evl (a 1))" "(evl (max 1 2))" "(run-tests)" "(my-let [] )" "(my-let \\n  [x 1\\n   y x] \\n  (+ x y))" "(source do)" "do" "(evl (def m-test (fn [v] (if (< v 0) (- v) v)) \:macro))" "(evl (m-test 1))" "(evl (m-test a))" "(evl (m-test (+ 1 1 )))" "(evl (def m-test (fn [v] v) \:macro))" "(evl (m-test (+ 1 1 )))" "(evl (m-test (+ 1 (+ 10 11) )))" "(evl (m-test (syntax-quote (+ 1 (+ 10 11) ))))" "(evl (m-test (syntax-quote (+ 1 (unquote (+ 10 11))))))" "(evl (def m-test (fn [v] (syntax-quote v)) \:macro))" "(evl (m-test (+ 1 1 )))" "(evl (def m-test (fn [v] (syntax-quote (def a (unquote v)))) \:macro))" "(evl (m-test (+ 1 1 )))" "(evl (def m-test (fn [v] (syntax-quote (def a (unquote v)))) \:macro))" "(defmacro c-test [v] `(def a ~v))" "(evl (t-test (+ 1 1 )))" "(t-test (+ 1 1 ))" "(c-test (+ 1 1 ))" "a" "(evl (def m-test (fn [v] (syntax-quote (def a (unquote v)))) \:macro))" "(evl (m-test (+ 1 1 )))" "(evl a)" "(run-tests)" "(evl (def m-test (fn [v] (syntax-quote (def a (unquote v)))) \:macro))" "(evl (m-test (+ 1 1 )))" "(evl a)" "(run-tests)" "(evl a-macro)" "(evl (def m-test (fn [v] (syntax-quote (def a (unquote v)))) \:macro))" "(evl a)" "(evl (def m-test (fn [v] (syntax-quote (def a (unquote v)))) \:macro))" "(evl (m-test [1 \:a]))" "(evl a)" "(run-tests)" "eval-exprs" "(first eval-exprs)" "(eval-expr1 '(+ 1 1) {} false eval-exprs)" "(partition 2 eval-exprs)" "eval-exprs" "(first eval-exprs)" "(partition 2 [1 2 3 4])" "(eval-expr1 '(+ 1 1) {} false eval-exprs)" "(eval-expr1 '1 {} false eval-exprs)" "(run-tests)" "(lisp-evals 1 true)" "(first (lisp-evals 1 true))" "(partition 2 (lisp-evals 1 true))" "((first (lisp-evals 1 true)) 1)" "(reduce + [1 2 3])" "(reduce (fn [a v] v) [1 2 3])" "(reduce (fn [a v] a) [1 2 3])" "(reduce (fn [a v] (reduced \:a)) [1 2 3])" "(reduce (fn [a v] (reduced \:a)) (lisp-evals '1 false))" "(reduce (fn [a v] (reduced \:a)) (partition 2 (lisp-evals '1 false)))" "(reduce (fn [a v] v) (partition 2 (lisp-evals '1 false)))" "(reduce (fn [a [p e]] v) (partition 2 (lisp-evals '1 false)))" "(reduce (fn [a [p e]] e) (partition 2 (lisp-evals '1 false)))" "(reduce (fn [a [p e]] (when (p '1) e)) (partition 2 (lisp-evals '1 false)))" "(clj-eval \\"1\\")" "(clj-eval \\"(+ 1 1)\\")" "(-> \\"(+ 1 1)\\" parser ast->clj)" "(-> \\"`(+ 1 1)\\" parser ast->clj)" "(-> \\"'(+ 1 1)\\" parser ast->clj)" "`(+ 1 1)" "`(+ a 1)" "`(+ ~a 1)" "(let [a 1] `(+ ~a 1))" "(-> \\"'(+ 1 1)\\" parser)" "(-> \\"`(+ 1 1)\\" parser)" "(fn [a] \\n  (fn [b]\\n    (+ a b))\\n  (+ a 1)\\n  1)" "((fn [a] \\n   (fn [b]\\n     (+ a b))\\n   (+ a 1)\\n   1))" "((fn [a] a) 1)" "((fn [a] (fn [b] (+ a b) (+ a 1) ) 1))" "((fn [a] (fn [b] (+ a b) (+ a 1)) 1))" "(def a (fn [a] a) 1)" "(def a ((fn [a] a) 1))" "a" "(def b (fn [b] (+ a 1)))" "b" "(def b ((fn [b] (+ a 1))))" "(def b ((fn [b] b) (+ a 1)))" "b" "a" "b" "((fn [a] a) 1)" "((fn [a] ((fn [b] b) (+ a 1))) 1)" "((fn [a] ((fn [b] (+ a b) (+ a 1))) 1))" "((fn [a] ((fn [b] (+ a b)) (+ a 1))) 1)" "(pprint ((fn [a] ((fn [b] (+ a b)) (+ a 1))) 1))" "(pprint '((fn [a] ((fn [b] (+ a b)) (+ a 1))) 1))" "(macroexpand-1 '(let1 [a 1] a))" "((fn [a] ((fn [b] (+ a b)) (+ a 1))) 1)" "(macroexpand-1 '(let1 [a 1] a))" "((clojure.core/fn [a]) 1)" "(macroexpand-1 '(let1 [a 1] a))" "((clojure.core/fn [a] (if (clojure.core/rest mylisp.eval/assignments) (if (clojure.core/\= (clojure.core/count mylisp.eval/assignments) 2) a (mylisp.eval/let1 (1) a)) 1)))" "(macroexpand-1 '(let1 [a 1] a))" "((clojure.core/fn [a] (if (clojure.core/rest [a 1]) (if (clojure.core/\= (clojure.core/count [a 1]) 2) a (mylisp.eval/let1 (1) a)) 1)))" "(macroexpand-1 '(let1 [a 1] a))" "(nil? [])" "(seq [])" "(macroexpand-1 '(let1 [a 1] a))" "((fn [a] ((fn [b] (+ a b)) (+ a 1))) 1)" "(macroexpand-1 '(let1 [a 1\\n                       b (+ a 1)] a))" "(macroexpand-1 '(let1 [a 1\\n                       b (+ a 1)] (+ a b)))" "((clojure.core/fn [a] ((clojure.core/fn [b] (+ a b)))))" "(macroexpand-1 '(let1 [a 1] a))" "(macroexpand-1 '(let1 [a 1\\n                       b (+ a 1)] (+ a b)))" "((clojure.core/fn [a] ((clojure.core/fn [b] (+ a b)) (+ a 1))) 1)" "(evl (if true \:a \:b))" "(evl (when true \:a))" "(evl (when false \:a))" "(source partition)" "(evl (quote (when false \:a)))" "(evl (when false \:a))" "(evl (when true \:a))" "(source defmacro)" "(source defn)" "(let1 [a 2\\n       b (+ a 3)]\\n  (* a b))" "(macroexpand-1 '(let1 [a 2\\n             b (+ a 3)]\\n        (* a b)))" "(reduce (fn [v a] [1 2 3 4]))" "(reduce (fn [v a]) [1 2 3 4])" "(reduce (fn [v a] a) [1 2 3 4])" "(reduce (fn [v a] v) [1 2 3 4])" "(reduce (fn [a v] v) [1 2 3 4])" "(reduce (fn [a v] (if empty? a) (conj [] v)) [1 2 3 4])" "(source partition)" "(part [1 2 3 4])" "(part [1 2 3 4 5 6])" "(part [1 2 3 4 5 6 7])" "(part [1 2 3 4 5 6])" "(evl (partition [1 2 3 4]))" "(evl (let [a 1] a))" "(evl (second [1 2]))" "(evl (let [a 1] a))" "(evl (let [a 1] 1))" "(macroexpand-1 '(let [a 1] a))" "(macroexpand-1 '(let1 [a 1] a))" "(macroexpand '(let1 [a 1] a))" "(macroexpand '(let1 [a 1 b 2] a))" "(macroexpand '(let1 [a 1 b 2] (+ a b)))" "(when true \:a)" "(evl (when true \:a))" "(evl (let [a 1] 1))" "(macroexpand-1 '(asdf 1))" "(evl (asdf 1))" "(macroexpand-1 '(asdf 1))" "(evl (let [a 1] 1))" "(evl (dbg 1))" "(println 1)" "(evl (dbg 1))" "(asdf 2)" "(macroexpand-1 '(asdf 2))" "(evl (dbg 1))" "(evl (println 1))" "(evl (dbg 1))" "(evl (println 1))" "(evl (dbg 1))" "(evl (println 1))" "(evl (dbg 1))" "global-env" "(keys @global-env)" "((keys @global-env) dbg)" "((keys @global-env) \\"dbg\\")" "((keys @global-env) (symbol \\"dbg\\"))" "(@global-env (symbol \\"dbg\\"))" "(asdf 2)" "(evl (println 1))" "(evl (dbg 1))" "(list? '(println 1))" "(evl (dbg 1))" "(seq [])" "(seq [1])" "(class (seq [1]))" "(map identity [1 2])" "(class (map identity [1 2]))" "(list? (class (map identity [1 2])))" "(seq? [])" "(seq? '())" "(coll? [])" "(list? (class (map identity [1 2])))" "(sequential? [])" "(seq? [])" "(seq? '())" "(seq? (map identity [1]))" "(evl (dbg 1))" "(evl (dbg \\"asdf\\"))" "(evl (let [a 1] a))" "(evl (let [a 1] (+ a 1)))" "(evl (let [a 1 \\n           b 2] (+ a b)))" "(evl (partition [1 2 3 4]))" "(evl (let [a (rest (rest [1 2]))]\\n       a))" "(evl (let [a (rest (rest [1 2 3]))]\\n       a))" "(evl (let [a (first (rest (rest [1 2 3])))]\\n       a))" "(evl (partition [1 2 3 4]))" "(evl (let [a 1\\n           b 2 \\n           c 3]\\n       (+ a b c)))" "(evl (dbg \\"asdf\\"))" "(dbg \\"asdf\\")" "(+ 1 1)" "(use 'mylisp.eval)" "(evl (+ 1 1))" "(evl (def a 1))" "(evl a)" "(use 'mylisp.eval)" "(evl (def a 1))" "(use 'mylisp.eval)" "(evl (def a 1))" "(evl a)" "(evl (def a-fn [x] (+ x 1)))" "(evl (def >\= (fn [v1 v2] (or (> v1 v2) (\= v1 v2)))))" "(evl (def >\= (fn [v1 v2] (or (> x v2) (\= v1 v2)))))" "(evl (def >\= (fn [v1 v2] (or (> v1 v2) (\= v1 v2)))))" "(evl (>\= 1 2))" "(evl (min 1 2))" "(evl (min 1 2 3))" "(evl (min 1 2 3 -1))" "(evl (reduce + [1 2 3]))" "(evl (reduce + 1 [1 2 3]))" "(evl (def a-fn (fn [x] (+ x 1))))" "(evl a-fn 1)" "(evl (a-fn 1))" "(evl (let [a 1\\n           b 2]\\n       (+ a b)))" "(evl (def a-fn (fn [x] (+ x 1))))" "(evl (a-fn 1))" "(run-tests)"]
eclipse.preferences.version=1
